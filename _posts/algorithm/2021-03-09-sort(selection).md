---
layout: post
title: 개요
description: >
  Selection Sort
hide_description: false
sitemap: false
date: 2021-03-09 11:22:00 +0900
category: algorithm
tag: [sort]
---

# 정렬(Sort)의 개요와 선택정렬(Selection Sort)

일반적으로 알고리즘을 공부할 때 가장 먼저 풀어보는 문제는 '정렬(Sort)' 문제이다. <u>정렬만큼 알고리즘의 효율성 차이를 극명하게 보여주는 것이 없기 때문이다.</u>
{:.note title="attetion"}

### 다음의 숫자들을 오름차순으로 정렬하는 프로그램 만들기

#### 1 10 5 8 7 6 4 3 2 9

---

### 가장 작은 것을 선택해서 제일 앞으로 보내기

```
1 10 5 8 7 6 4 3 2 9

1 2 5 8 7 6 4 3 10 9

1 2 3 8 7 6 4 5 10 9

1 2 3 4 7 6 8 5 10 9

1 2 3 4 5 6 8 7 10 9

...

1 2 3 4 5 6 7 8 9 10
```

### 이런 과정을 for문을 이용해 구현

```c
#include <stdio.h>

int main(void) {
    int i, j, min, index, temp;
    int array[10] = {1, 10, 5, 8, 7, 6, 4, 3, 2, 9};
    for (i = 0; i < 10; i++){
        min = 9999;
        // 항상 최소값을 골라야하기 때문에 배열에 있는 수 보다 더 큰 숫자로 지정해야한다.
        for(j = i; j < 10; j++){
            if(min> array[j]){
                index=j;
                min=array[j];
            }
        }
        // 스와핑
        temp = array[i];
        array[i] = array[index];
        array[index] = temp;
    }
    for(i = 0; i < 10; i++){
        printf("%d ", array[i]);
    }
    return 0;
}
```

### 시간 복잡도 big O

> 시간복잡도란 해당 로직이 수행될 때 몇 번의 연산이 이루어지는지를 판단해 쉽게 비교할 수 있는 지표로 활용하는 단위.
> 당연하게도 시간복잡도가 높을수록 수행되는 연산이 많다는 뜻이므로 시간이 좀 더 길게 걸리게 된다.
> 표기법은 `O(n)`과 같이 n을 사용해 표현한다.

&nbsp;&nbsp;총 n개의 데이터가 있을 때 선택정렬의 연산횟수는 $$ \frac{n*(n+1)}{2} $$ 이다. 이를 컴퓨터에서는 가장 큰 차수인 $$ n^2 $$ 만 보고 $$ O(N^2) $$ 이라고 표현한다.
&nbsp;&nbsp;즉 정렬해야 할 데이터의 개수가 10,000 개라면 대략 1억 번 정도 계산을 한다고 가정하겠다는 의미이다. $$ f(x) = x^2 $$ 의 함수를 보면 x값이 커질수록 y의 값이 **기하급수적으로** 늘어나는 양상을 보인다. 이를 보면 이 선택정렬 알고리즘은 데이터의 수가 늘어날수록 상당히 비효율적인 모습을 보이리라 예상할 수 있다.