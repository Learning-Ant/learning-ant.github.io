---
layout: post
title: Pointer
description: >
  C 언어의 Pointer
hide_description: true
sitemap: false
date: 2021-03-13 12:23:00 +0900
category: language
tag: [c]
---

# 포인터(Pointer)

> Pointer는 C언어가 Low Level Language의 특성을 지닌다고 이야기하게 만든 개념이다. 포인터를 이용하면 메모리에 직접적인 접근이 가능하기 때문이다.
{:.note title="attention"}

### Pinter와 Pointer 변수

* 메모리의 **주소 값을 저장**하기 위한 변수
* "Pointer"를 흔히 "Pointer 변수"라 한다.
* 주소 값과 포인터는 다른 것이다.

> Pointer의 크기는 컴퓨터의 시스템이 몇 비트의 시스템인지에 따라 달라진다.
> 32비트 시스템 : 4바이트
> 64비트 시스템 : 8바이트
{:.note}

### 그림을 통한 포인터의 이해

![포인터](/assets/img/language/c/pointer.png)
{:.lead loading="lazy" align="center"}

포인터는 가리키는 변수 시작의 주소값을 저장한다.
{:.figcaption}

&nbsp;&nbsp;위의 그림처럼 포인터는 어떤 한 변수의 주소값을 저장하며 보통 "pN 포인터는 변수 n을 『가리킨다』"고 표현한다.

### 포인터의 타입과 선언

* 포인터 선언 시 사용되는 연산자 : *
* A형 포인터(A*) : A(int, double, char, ...)형 변수의 주소 값을 저장

```c
int main(void)
{
    int *a;     // a 라는 이름의 int형 포인터
    char* b;    // b 라는 이름의 char형 포인터
    double * c;  // c 라는 이름의 double형 포인터

    // *와 변수명, 타입 사이사이에 띄워쓰기는 상관이 없다.
}
```

* 주소 관련 연산자
    1. &연산자 : 변수의 주소 값 반환
    2. *연산자 : 포인터가 가리키는 메모리 참조

```c
// pointer1.c
#include <stdio.h>

int main(void)
{
    int num = 7;
    int* pNum;              // 포인터 변수 pNum의 선언
    pNum =  &num;           // num의 주소 값을 포인터 변수 pNum에 저장
    printf("%d", num);      // 직접 접근
    printf("%d", *pNum);     // 간접 접근
    // *pNum이 아닌 pNum을 적으면 num의 메모리의 주소값을 10진수 정수형으로 보여준다.
    // *를 붙혀주어야 포인터에 저장된 주소값을 참조하여 데이터를 보여준다.

    return 0;
}
```

> 피연산자를 통해 '*'가 곱셈인지 선언인지 접근인지를 판단할 수 있다.
> a*b -> 곱셈
> int* p; -> 선언
> *p -> 접근
{:.note}

### 포인터에 다양한 타입이 존재하는 이유

* 포인터 타입은 참조할 <u>메모리의 크기 정보</u>를 제공한다.

&nbsp;&nbsp;포인터를 이용한 참조를 가능하게 하기위해 타입이 존재하는 것이다. 예를 들어 double형으로 선언된 변수가 있고, 이를 int형 pointer에 그 주소값을 저장했을 때를 생각해보자.  
&nbsp;&nbsp;실제로 저장된 변수는 총 8byte의 공간을 차지하고 있고, int형으로 선언된 pointer는 그 8byte중 4byte만을 가지고 올 것이다. int는 4byte의 공간을 차지하기 때문이다. 즉 int형 pointer가 참조하여 가져온 값은 예측이 불가능한 의미없는 값이 되는 것이다.  
&nbsp;&nbsp;이처럼 pointer가 어떤 type인지를 명시해주어야 해당 주소값으로부터 어디까지의 메모리공간을 읽어들여 데이터를 불러올 것인지를 정확히 인지하고 올바른 데이터를 가져올 수 있게 되는 것이다.

### 잘못된 포인터의 사용

> 간단한 사례를 통해 학습한다.
{:.note}

```c
int main(void)
{
    int* pA;    // pA는 쓰레기 값으로 초기화 된다.
    *pA = 10;   // compile은 무리없이 되지만 실행 시 OS에서 막는다.
                // 정확히 어떤 위치의 메모리인지 알 수 없고 이는 상당히 위험한 행위

    pA = 100;   // 100의 위치에 있는 메모리가 어디인지 우리는 정확히 알 수 없다.
    *pA = 10;

    return 0;
}
```

&nbsp;&nbsp;만약 위의 소스처럼 포인터를 선언했지만 바로 초기화하지않고 후에 초기화할 생각이라면 어떤 값으로 미리 초기화 시켜두는 것이 좋을까? 포인터 변수를 우선 선언만 해 놓고, 이후에 유효한 주소 값을 채워 넣을 생각이라면 다음과 같이 초기화를 하는 것이 좋다고 한다.

```c
int main(void)
{
    int* ptr1 = 0;
    int* ptr2 = null    // null은 사실상 0을 의미한다.
    return 0;
}
```

&nbsp;&nbsp;위에서 ptr1을 초기화하는 값 0을 가리켜 '널 포인터'라 한다. 이는 0번지를 의미하는 것이 아니라 아무것도 가리키지 않는다는 의미이다. 
<br/>
---

&nbsp;&nbsp;끝으로 포인터는 그 특성상 다양한 형태의 버그 발생확률을 높이기 때문에, 처음에는 포인터의 사용이 부담스러울 수 있다. 실제로 잘못된 포인터의 사용으로 인해 디버깅하느라 많은 시간을 소요할 수 있다. 하지만 이런 과정을 거치면서 보다 안정적으로 프로그래밍을 할 수 있게 될 수 있지 않을까? 중요한 것은 그런 과정을 거친 후에 고친 결과에 집중하는 것이 아닌 그 과정에 집중하여 그러한 실수를 반복하지 않거나, 반복하더라도 바로 고칠 수 있게 되는 것이다.