---
layout: post
title: Linked List
description: >
  링크드 리스트의 구현
hide_description: true
sitemap: false
date: 2021-03-23 23:16:00 +0900
category: data-structure
tag: [List,c]
---

# List - Linked List

> 리스트 중의 하나인 링크드 리스트는 해석하자면 `연결해서 만드는 리스트`라는 의미가 된다. 그럼 어떤 것을 연결한 것일까?  
> 리스트의 각 요소는 노드(Node)라고 부른다. 노드는 우리말로 `마디`라는 의미이다. 이 노드를 연결한 것이 바로 `Linked List`이다.
{:.note title="attention"}

## C에서의 Linked List

### Node

> C 언어에서는 각각의 노드를 `구조체`로 구현한다. 이 `구조체 노드`는 아래와 같이 구현이 가능하다.

```c
typedef struct tagNode
{
    int Data;
    // 노드에 들어가는 데이터
    struct Node * NextNode;
    // 다음 노드를 가리키는 포인터
} Node;
```

&nbsp;&nbsp;아는 사람은 알테지만 Linked List는 Index로 접근이 불가능하다. 대신 다음 노드를 가리키는 포인터를 가짐으로써 다음 노드가 무엇인지 알 수 있다.
이 포인터로 리스트의 노드 추가, 탐색, 삭제, 삽입 등이 가능한 것이다. 당연히 Index가 없으니 배열과 같은 Indexing이 불가능하다.

### Linked List의 주요연산

> 기본적으로 링크드 리스트를 구축하고 링크드 리스트에 있는 자료를 사용하기 위해 필요한 연산은 다음 다섯가지이다.
{:.note title="attention"}

1. 노드 생성/소멸
2. 노드 추가
3. 노드 탐색
4. 노드 삭제
5. 노드 삽입

### 노드의 생성/소멸

> C언어를 배웠다면 프로그램이 구동될 때 어떤 메모리들이 있는지 어느정도는 알고 있을 것이다. 크게 정적 메모리인 `데이터 영역`이 있고, Stack 영역이라 불리는 `자동 메모리(Automatic Memory)`, Heap이라 불리는 `자유 저장소(Free Store)`가 있다.  
> 데이터 영역은 Life Span이 프로그램 종료까지인 전역변수(Global Variable), 정적변수(Static Variable)가 저장되고, 자동메모리에는 지역변수, 자유 저장소는 동적 할당이 가능한 공간이다.  
> 그렇다면 노드는 어떤 메모리에 저장해야 할까?
{:.note title="attention"}

* 먼저 Stack에 저장하는 경우를 코드로 살펴보자.

```c
typedef struct tagNode
{
    int Data;
    // 노드에 들어가는 데이터
    struct Node * NextNode;
    // 다음 노드를 가리키는 포인터
} Node;

Node* createNode(int newData)
{
    Node newNode;
    // 지역변수이므로 자동메모리에 할당
    newNode.Data = newData;
    newNode.NextNode = NULL;

    return &newNode;
    // 노드가 새로 생성된 주소값을 반환하지만
    // 지역변수는 scope에 의해 함수가 종료되는 순간 사라진다.
}
// 이 때 새로운 노드 포인터를 선언하고
// 함수를 이용해 초기화하면 과연 어떻게 될까?
Node* newNode = createNode(120);
// 함수는 주소값을 반환하겠지만 해당 주소값에는 아무 데이터도 없을 것이다.
```

&nbsp;&nbsp;위의 예시로 우리는 Node를 어디에 할당해야할지 명확하게 알 수 있다. 노드는 `자유 저장소`, 즉 `Heap` 영역에 저장해야한다.
그 Heap영역에 할당하기 위해 필요한 것이 `malloc()와 free()`이다. 아래의 코드를 살펴보자.

```c
typedef int ElementType;
typedef struct tagNode
{
    int Data;
    // 노드에 들어가는 데이터
    struct Node * NextNode;
    // 다음 노드를 가리키는 포인터
} Node;

// 노드 생성
Node* SLL_CreateNode(ElementType NewData)
{
    Node* NewNode = (Node*)malloc(sizeof(Node));
    // Heap 영역에 할당하고 Node형 포인터로 casting

    NewNode->Data = NewData;
    // Data로 인자값을 전달
    NewNode->NextNode = NULL;
    // 다음 노드는 아직 무엇인지 모르니 Null 포인터로 초기화

    return NewNode;
    // 만든 Node(포인터)를 반환
}

// 노드 소멸
void SLL_DestroyNode(Node* Node)
{
    free(Node);
    // 인자로 받은 Node를 소멸
}
```

### 노드 추가

> 노드의 추가는 삽입과 달리 리스트의 가장 마지막 노드인 Tail 뒤에 새로운 노드를 연결하는 것을 의미한다.  
> 즉, 리스트의 Head부터 시작해 Tail을 찾고 Tail의 멤버변수인 `Node* NextNode`에 인자로 전달된 새로운 노드를 대입하면 된다.
{:.note title="attention"}

* AppendNode() 구현

```c
void SLL_AppendNode(Node** Head, Node* NewNode)
{
    // 헤드 노드가 NULL이면(없으면), 새로운 노드가 Head가 된다.
    if ( (*Head) == NULL )
    {
        *Head = NewNode;
    }
    else
    {
        // Head부터 Tail을 찾아간다.
        Node* Tail = (*Head)
        while ( Tail->NextNode != NULL )
        {
            Tail = Tail->NextNode
        }
        Tail->NextNode = NewNode;
    }
}
```

&nbsp;&nbsp;구현은 되었고 이제 이를 어떻게 사용해야할까? 아래 예제로 살펴본다.

```c
Node* List = NULL;
Node* NewNode = NULL;

NewNode = SSL_CreateNode(11);
SLL_AppendNode( &List, NewNode );

NewNode = SSL_CreateNode(22);
SLL_AppendNode( &List, NewNode);
```

> 첫 번째 매개변수로 전달해주는 것이 List의 주소값임을 유의하자.  
> 여기서 SSL_AppendNode()함수에 첫 인자의 타입이 `포인터의 포인터(Node**)`인 이유가 의아할 수 있다.  
> 그 이유는 List는 일단 가장 첫번째 노드인 Head를 가리키는 포인터이다. 따라서 처음에는 노드가 없는 상태인 `NULL`의 상태인 것.  
> 그렇다면 List에 Head를 추가하려면 그 List를 가리키는 포인터를 받아 List에 Head Node를 가리키는 포인터를 추가해야한다.  
> 따라서, SSL_AppendNode()에서 List를 받는 인자는 포인터의 포인터가 되어야한다.
{:note title="attention"}

### 노드 탐색

> 탐색 연산은 Linked List가 가지고 있는 약점 중의 하나이다. 배열은 인덱스로 접근이 가능해 원하는 요소를 바로 취할 수 있게 하지만
> Linked List는 헤드부터 시작해 하나씩 차근차근 노드의 수를 세어나가야만 원하는 요소에 접근할 수 있다.
{:.note title="attention"}

* GetNodeAt() 구현

```c
Node* SLL_GetNodeAt(Node* Head, int Location)
{
    Node* Current = Head;

    while ( Current != NULL && (--Location) >= 0)
    {
        Current = Current->NextNode;
    }

    return Current;
}
```

&nbsp;&nbsp;코드를 봐서는 그렇게 어렵진 않다. 원하는 위치값을 인자로 전달해주고, 하나씩 감소시켜가며 해당 위치를 찾아가는 로직이다.
사용은 간단하지만 상당히 비효율적인 로직이다. 이는 Linked List의 어쩔 수 없는 약점이다.

### 노드 삭제

> 